/*
 * EquationHandler.h
 *
 *  Created on: 05.08.2016
 *      Author: Klarmann
 */



#include <preprocessDefine.h>

#include <equations/EquationHandler.h>

#include <control/OutputHandler.h>
#include <control/HandlingStructs.h>

#include <pointercollection/pointercollection.h>
#include <equations/DegreeOfFreedom.h>
#include <equations/DofStatus.h>
#include <equations/NodeSet.h>
#include <equations/GenericNodes.h>

#include <solver/GenericSolutionState.h>

#include <iostream>
#include <iomanip>


namespace FEMProject {
	
	template<typename prec, typename uint>
	EquationHandler<prec,uint>::EquationHandler(PointerCollection<prec, uint> *ptrCol){
		this->pointers = ptrCol;
		this->currNodeSets = 0;
		this->currNodes    = 0;
		this->nodesetCompressedIndex.push_back(0);
		this->nodesIndex.push_back(0);
		this->activeIds   = 0;
		this->inActiveIds = 0;
		this->totalIds	  = 0;
	}
	
	
	template<typename prec, typename uint>
	EquationHandler<prec,uint>::~EquationHandler(){
		this->pointers = 0;
	}
	
	
	/**
	 * @brief Request a node set collection.
	 * @param numberOfSets Specifies the number of node sets.
	 * @return Returns the storage number of the node set collection to identify the set collection later on.
	 */
	template<typename prec, typename uint>
	uint EquationHandler<prec,uint>::requestNodeSets(const unsigned char &numberOfSets){
		uint setCollectionIndex = static_cast<uint>(this->nodesetCompressedIndex.size())-1;
	
		this->nodesetCompressedIndex.push_back(this->nodesetCompressedIndex.back()+numberOfSets);
	
		for(auto i=0;i<numberOfSets;++i){
			this->nodeSetList.emplace_back();
		}
	
		return setCollectionIndex;
	}
	
	
	/**
	 * @brief Returns a pointer to a node set.
	 * @param setCollectionIndex Index of the node sets, generated by requestNodeSets.
	 * @param setNumber Offset to the number of the node set, first node set in the group has index 0.
	 * @return Returns the selected node set.
	 */
	template<typename prec, typename uint>
	NodeSet<prec,uint> *EquationHandler<prec,uint>::getSet(const uint &setCollectionIndex, const unsigned char &setNumber){
		// TODO Adding an exception when trying to access non present node set. //
	
		if(static_cast<std::size_t>(setCollectionIndex)<this->nodesetCompressedIndex.size()){
			uint pos = this->nodesetCompressedIndex[setCollectionIndex]+setNumber;
			return &this->nodeSetList[pos];
		}else{
			return 0;
		}
	}
	
	
	/**
	* @brief Returns a pointer to a node set.
	* @param setCollectionIndex Index of the node sets, generated by requestNodeSets.
	* @param setNumber Offset to the number of the node set, first node set in the group has index 0.
	* @return Returns the selected node set.
	*/
	template<typename prec, typename uint>
	NodeSet<prec, uint> *EquationHandler<prec, uint>::getSetMeshId(const uint &setCollectionIndex, const unsigned char &meshId) {
		// TODO Adding an exception when trying to access non present node set. //
	
		uint sets = this->nodesetCompressedIndex[setCollectionIndex + 1] - this->nodesetCompressedIndex[setCollectionIndex];
		bool search = true;
		uint pos = 0;
		NodeSet<prec, uint> *tempSet;
		while (pos < sets && search) {
			tempSet = &this->nodeSetList[setCollectionIndex + pos];
			if (tempSet->getMeshId()==meshId) {
				search = false;
			}
			++pos;
		} 
	
		if (search) {
			//TODO throw exception
			InfoData *tempInfo = this->pointers->getInfoData();
			tempInfo->Log(LogLevel::NoLog, LogLevel::NoLog) << "No set with given mesh id " << (int)meshId << " for set collection " << setCollectionIndex << std::endl;
			tempSet = 0;
		}
	
		return tempSet;
	}
	
	
	/**
	 * @brief Sets up a vector with node set pointer.
	 * @param nodeSets Vector of pointer to the node sets. Will be set up on call.
	 * @param setCollectionIndex Storage index of the set collection.
	 * @param setSize The size of the set collection.
	 */
	template<typename prec,typename uint>
	void EquationHandler<prec,uint>::getSets(std::vector<NodeSet<prec,uint>*> &nodeSets, const uint &setCollectionIndex, const unsigned char &setSize){
		std::size_t colIndex = static_cast<std::size_t>(setCollectionIndex) ;
		if(colIndex < this->nodesetCompressedIndex.size()-1){
			uint setLength = this->nodesetCompressedIndex[setCollectionIndex+1]-this->nodesetCompressedIndex[setCollectionIndex];
			uint startIndex = this->nodesetCompressedIndex[setCollectionIndex];
			nodeSets.clear();
			if(setLength>setSize){
				//TODO Add exception different sizes.
			}
			for(auto i=0;i<setLength;++i){
				nodeSets.push_back(&this->nodeSetList[startIndex+i]);
			}
		}else{
			// TODO Adding an exception when trying to access non present node set collection. //
		}
	}
	
	/**
	 * @brief Updates the nodes correspondig to node sets.
	 */
	template<typename prec,typename uint>
	void EquationHandler<prec,uint>::update(){
		typename std::vector<NodeSet<prec,uint>>::iterator it = this->nodeSetList.begin();
		uint setSize = static_cast<uint>(this->nodeSetList.size());
		while(this->currNodeSets<setSize){
			NodeSet<prec,uint> *temp = &this->nodeSetList[currNodeSets];
		
			uint num;
			num = temp->getNumberOfNodes();
			temp->setNodeStorageId(static_cast<uint>(this->nodesIndex.size()) - 1); // Set nodeset storage id
			for (auto i = 0; i<num; ++i) {
				this->nodes.emplace_back();  // Add the node to the list
				this->nodes.back().setId(this->currNodes);		  // Assign the node Id
				this->nodes.back().setNodeType(temp->getNodeSetType()); // Assign the node type
				this->nodes.back().requestEquationIds(*this->pointers);		  // Request the Specific amount of degrees of freedom
				++this->currNodes;
			}
			this->nodesIndex.push_back(static_cast<uint>(this->nodes.size()));
		
			++this->currNodeSets;
		}
	}
	
	
	template<typename prec,typename uint>
	void EquationHandler<prec,uint>::print(std::ostream &out){
	
		std::cout << "Equation Handler Informations: " << std::endl;
		std::cout << std::setw(30) << std::left  << "Current Nodesets:";
		std::cout << std::setw(30) << std::right << this->currNodeSets << std::endl;
		std::cout << std::setw(30) << std::left  << "Current Displacement Nodes:";
		std::cout << std::setw(30) << std::right << this->nodes.size() << std::endl;
	
	}
	
	
	template<typename prec, typename uint>
	GenericNodes<prec, uint> *EquationHandler < prec, uint>::getNode(NodeSet<prec, uint> &nodeSet, const unsigned char &node) {
		const unsigned char nodesInSet = nodeSet.getNumberOfNodes();
		if (node >= nodesInSet) {
			//TODO throw exception
			std::cout << "Node not in set" << std::endl;
		}
		uint storageId = nodeSet.getNodeStorageStartId();
		GenericNodes<prec, uint> *ret = 0;
		uint compressedIndex = this->nodesIndex[storageId];
		ret = &this->nodes[compressedIndex + node];
	
		return ret;
	}
	
	
	template <typename prec, typename uint>
	void EquationHandler<prec, uint>::getNodes(std::vector<GenericNodes<prec, uint>*> &nodes, const uint &setCollectionIndex, const unsigned char &setNumber) {
		if (setCollectionIndex >= static_cast<uint>(this->nodesetCompressedIndex.size())) {
			//TODO throw exception
			std::cout << "Node set not present" << std::endl;
		}
		const unsigned char sets = static_cast<unsigned char>(this->nodesetCompressedIndex[setCollectionIndex + 1] - this->nodesetCompressedIndex[setCollectionIndex]);
		if (setNumber >= sets) {
			//TODO throw exception
			std::cout << "Set not in setgroup" << std::endl;
		}
		uint pos = this->nodesetCompressedIndex[setCollectionIndex] + static_cast<uint>(setNumber);
		NodeSet<prec, uint> *tempSet;
		tempSet = &this->nodeSetList[pos];
		const unsigned char numberOfNodes = tempSet->getNumberOfNodes();
		nodes.resize(numberOfNodes);
		
	
		
		for (auto i = 0; i < numberOfNodes; ++i) {
			nodes[i] = this->getNode(*tempSet, i);
		}
	}


	template<typename prec, typename uint>
	void EquationHandler<prec, uint>::getNodes(std::vector<GenericNodes<prec, uint>*> &nodesOut, const NodeSet<prec, uint> &Nodeset) {
		uint NodeStorageId = Nodeset.getNodeStorageStartId();
		uint numOfNodes = Nodeset.getNumberOfNodes();
		nodesOut.clear();
		
		for (auto i = 0; i < numOfNodes; ++i) {
			nodesOut.push_back(&this->nodes[this->nodesIndex[NodeStorageId]+i]);
		}

	}


	
	template<typename prec, typename uint>
	void EquationHandler<prec, uint>::initSolutionState() {
		this->pointers->getSolutionState()->setInitialValues(this->totalIds, this->activeIds);
	}


	template<typename prec, typename uint>
	uint EquationHandler<prec, uint>::requestDegreesOfFreedom(const uint number) {
		
		uint pos = static_cast<uint>(this->degreesOfFreedom.size());
		

		for (auto i = 0; i < 3; ++i) {
			this->degreesOfFreedom.emplace_back();
			this->degreesOfFreedom.back().setId(pos + i);
		}
		//this->degreesOfFreedom.back().setStatus(dofStatus::inactive);
		return pos;
	}

	template<typename prec, typename uint>
	void EquationHandler<prec, uint>::getDegreesOfFreedom(const uint &indexpos, std::vector<DegreeOfFreedom<prec, uint>*> &Dofs) {
		
		Dofs.clear();

		for (auto i = indexpos; i < indexpos + 3; ++i) {
			Dofs.push_back(&this->degreesOfFreedom[i]);
		}

	}


	template<typename prec, typename uint>
	void EquationHandler<prec, uint>::updateEquations() {
		auto len = this->degreesOfFreedom.size();
		this->activeIds = 0;
		this->inActiveIds = 0;
		this->totalIds = 0;
		for (auto i = 0; i < len; ++i) {
			if (this->degreesOfFreedom[i].getStatus() == dofStatus::active) {
				this->degreesOfFreedom[i].setEqId(this->activeIds);
				++this->activeIds;
				++this->totalIds;
			} 
			else if (this->degreesOfFreedom[i].getStatus() == dofStatus::inactive) {
				this->degreesOfFreedom[i].setEqId(this->inActiveIds);
				++this->inActiveIds;
				++this->totalIds;
			}
		}
		for (auto i = 0; i < len; ++i) {
			if (this->degreesOfFreedom[i].getStatus() == dofStatus::linked) {
				uint masterNode = this->degreesOfFreedom[i].getlinkedTo();
				uint eqId = this->degreesOfFreedom[masterNode].getEqId();
				this->degreesOfFreedom[i].setEqId(eqId);
				++this->totalIds;
			}
		}
	}

	template<typename prec, typename uint>
	std::vector<DegreeOfFreedom<prec, uint>> *EquationHandler<prec, uint>::getDegreesOfFreedomList() {
		return &this->degreesOfFreedom;
	}

} /* namespace FEMProject */


instantiate(EquationHandler)
